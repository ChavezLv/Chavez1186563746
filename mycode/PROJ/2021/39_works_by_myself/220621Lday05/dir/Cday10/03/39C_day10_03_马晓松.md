# 王道训练营C++方向--基础023

## 题目描述

- (a). 实现二分查找有序数组。
- (b). 描述哈希查找的基本流程。
- (c). 什么是哈希冲突？如何解决哈希冲突？各种解决方法的优劣如何？

## 答案

- (a)

```c
#include<stdio.h>
#include<stdlib.h>
int binarysearch(int *arr,int length, int target) {
	int left = 0, right = length - 1;
	while (left <= right) {
		int mid = left + ((left + right) >> 1);
		if (arr[mid] == target) {
			return mid;
		}
		else if (arr[mid] > target) {
			right = mid - 1;
		}
		else {
			left = mid + 1;
		}
	}
	return 0;
}
```

- (b)

```c
插入流程：先将已经创建好的哈希表置为空，然后根据传入的元素e通过已经写好的hash(e)得到一个index,将e所对应的信息插入到哈希表中的indeX的位置；
查询流程：根据要查询的元素e通过已经写好的hash(e)得到一个index，根据index查询hashTable(index)即可得到e的元素信息以及位置。
   
```

- (c)

```c
不同的元素被hash()处理之后得到了相同的哈希值，这样就会产生冲突，因为在哈希表中哈希值是唯一的。
哈希冲突发生之后，有两种解决方案：
1.开放寻址法：
  在hash函数中设置两个参数，其中一个是要传入的参数e,另外一个则是用来记录发生冲突的次数，当哈希表中每次发生冲突的时候，hash中的参数e则会向后移动位置，从而解决冲突的问题。此方法的优点就是不用申请新的内存，缺点是不方便找到同一哈希值的所有节点，在某些特定情况下，会因为冲突还有插入顺序的问题，导致本该插入的对应哈希值的元素后移，从而导致对应不上， 导致鸠占鹊巢的问题。
2.链表法
  链表法用于处理冲突时，可以将冲突的元素额外申请一个结点将其信息还有地址存储进来，构成一个链表，从而解决了鸠占鹊巢的的问题，也方便找到同一哈希值的所有节点，不过缺点就是需要额外申请新的内存。
```

- ...

## 拓展知识

哈希表经常用于某些语言的字符串底层实现，以提升字符串处理的速度。