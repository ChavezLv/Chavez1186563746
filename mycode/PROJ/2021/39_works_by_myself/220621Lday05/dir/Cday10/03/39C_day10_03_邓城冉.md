# 王道训练营C++方向--基础023

## 题目描述

- (a). 实现二分查找有序数组。
- (b). 描述哈希查找的基本流程。
- (c). 什么是哈希冲突？如何解决哈希冲突？各种解决方法的优劣如何？

## 答案

- (a)

```c
//实现二分查找有序数组
#include <stdio.h>
#include <stdlib.h>
#define N 10
int binarySearch(int arr[], int n, int target)
{
    int low = 0, high = n - 1, mid;
    do
    {
        mid = low + (high - low) / 2;
        if (arr[mid] > target)
        {
            high = mid - 1;
        }
        if (arr[mid] < target)
        {
            low = mid + 1;
        }
        if(arr[mid] == target)
            return mid;
    } while (low <= high);
    if (low > high)
        return -1;
}
int main()
{
    int num[N] = {0};
    for (int i = 0; i <= N; i++)
    {
        num[i] = (i+1)*(i+1);
        printf("%d ", num[i]);
    }
    printf("\n");
    for (int j = 0; j < N + 2; j++)
    {
        printf("%d ", binarySearch(num, N, j*j));
    }
    printf("\n");
    system("pause");
    return 0;
}
```

- (b)

```c
哈希插入：
step1 取数据元素的关键字key，计算其哈希函数值。若该地址对应的存储空间还没有被占用，则将该元素存入；否则执行step2解决冲突。
step2 根据选择的冲突处理方法，计算关键字key的下一个存储地址。若下一个存储地址仍被占用，则继续执行step2，直到找到能用的存储地址为止。
哈希查找：
设哈希表为HST[0~M-1]，哈希函数取H（key），解决冲突的方法为R（x）；
Step1 对给定k值，计算哈希地址 Di=H（k）；若HST为空，则查找失败；若HST=k，则查找成功；否则，执行step2（处理冲突）。
Step2 重复计算处理冲突的下一个存储地址 Dk=R（Dk-1），直到HST[Dk]为空，或HST[Dk]=k为止。若HST[Dk]=K，则查找成功，否则查找失败。
```

- (c)

```c
哈希冲突是指哈希函数算出来的地址被别的元素占用了，也就是，这个位置有人了
开放定址法：
也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。
链地址法
这种方法的是将所有哈希地址相同的元素i构成一个单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在单链表中进行。链地址法适用于经常进行插入和删除的情况。
优缺点：
     1.开放地址法：容易产生堆积问题；不适于大规模的数据存储；散列函数的设计对冲突会有很大的影响；插入时可能会出现多次冲突的现象，删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂；结点规模很大时会浪费很多空间；
     2.链地址法：处理冲突简单，且无堆积现象，平均查找长度短；链表中的结点是动态申请的，适合构造表不能确定长度的情况；相对而言，拉链法的指针域可以忽略不计，因此较开放地址法更加节省空间。插入结点应该在链首，删除结点比较方便，只需调整指针而不需要对其他冲突元素作调整
```

## 拓展知识

**哈希表经常用于某些语言的字符串底层实现，以提升字符串处理的速度。**